﻿<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on http://github.com/jonrohan -->
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <link rel="stylesheet" href="../stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" href="../stylesheets/pygment_trac.css">
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script type="text/javascript" src="../javascripts/script.js"></script>

  <title>马文斌@博客</title>
  <meta name="description" content="">

  <meta name="viewport" content="width=device-width,initial-scale=1">

</head>

<body>

  <div class="wrapper">
    <header>
      <h1 class="title">马文斌@博客</h1>
    </header>
    <div id="container">
      <p class="tagline"></p>
      <div id="main" role="main">
        <div class="download-bar">
        <div class="inner">
          <a href="https://github.com/mwb1219" class="code">阅读正文</a>
        </div>
        <span class="blc"></span><span class="trc"></span>
        </div>
        <article class="markdown-body">
		


<!-- Blog Post -->
<!-- Title -->
<h2>
  Zookeeper和Curator-Framework实践之：分布式消息队列
  <div class="post-date"><a href="https://github.com/panxw/panxw.github.com/edit/master/_posts/2014-11-26-Distributed-Message-Passing.md" target="_blank">纠错</a>&nbsp;&nbsp;
	<span class="glyphicon glyphicon-time"></span>
	26 Nov 2014
  </div>
</h2>
<!-- Author -->
<hr>
<h2>一、队列应用场景</h2>

<p>一个典型的生产消费者模型，如下图：</p>

<p><img src="/images/MessageQueue/messagequeue01.png" alt="&quot;messagequeue01&quot;" /></p>

<p>WEB点提交要处理的数据，注意是多结点的也就是多个生产者，数量可能比较大。在后台有个处理者也就是消费者，注意前后是分开的，生产者应用本身不做消费，而Curator提供的API好像默认是一起的，一个应用既是生产者又可以做消费。</p>

<h2>二、配置</h2>

<p>一切都基于前面的示例 Zookeeper和Curator-Framework实践系列之： 配置管理 ，下面只说不一样的地方：applicationContext.xml</p>

<p>同样与<strong>Zookeeper和Curator-Framework实践系列之：配置管理</strong>相同，只需配置一下<strong>zookeeperFactoryBean 的 listeners 增加或修改成 DistributedQueueDemo</strong></p>

<pre><code>&lt;bean id="zookeeperFactoryBean" class="cn.bg.zk.core.ZookeeperFactoryBean" lazy-init="false"&gt;
    &lt;property name="zkConnectionString" value="zookeepermaster:2181"/&gt;
    &lt;property name="listeners"&gt;
        &lt;list&gt;
            &lt;bean class="cn.bg.zk.queues.DistributedQueueDemo"&gt;&lt;/bean&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>添加一个bean，指定CuratorFramework，充当生产者时需用用它来添加数据到队列</p>

<pre><code>&lt;bean id="mainController" class="cn.bg.controller.MainController"&gt;
    &lt;constructor-arg ref="zookeeperFactoryBean" /&gt;
&lt;/bean&gt;
</code></pre>

<h3>2.1、分布式队列处理类：DistributedQueueDemo.java</h3>

<pre><code>package cn.bg.zk.queues;
public class DistributedQueueDemo implements IZKListener{

    //申明两个队列实例
    private DistributedQueue&lt;String&gt; queue1 = null;
    private DistributedQueue&lt;String&gt; queue2 = null;

    //数据系列化转换工具类
    private QueueSerializer&lt;String&gt; serializer = new QueueItemSerializer();

    //消费者处理方法
    private QueueConsumer&lt;String&gt; consumer = new QueueConsumer&lt;String&gt;() {
        @Override
        public void consumeMessage(String message) throws Exception {
            //线程等待5秒，模拟数据处理，以达到数据抢夺的目的
            Thread.sleep(5000);
            //打印出是哪个线程处理了哪些数据
            System.out.println(Thread.currentThread().getId() +  " consume: " + message);
        }

        @Override
        public void stateChanged(CuratorFramework client, ConnectionState newState) {
            System.out.println("new state: " + newState);
        }
    };

    //Spring启动时调用此方法以启动所有队列实例    
    @Override
    public void executor(CuratorFramework client) {
        //实例化所有队列，指定ZK队列数据获取地址，和其它参数
        //由于它们的地址是相同的，都是*/zk_queue_test*，所以Curator会根据它们的空闲状态来分配新的任务，上面通过线程暂停5秒来拉开它们的处理间隔。
        queue1 = QueueBuilder.builder(client, consumer, serializer, "/zk_queue_test").buildQueue();
        queue2 = QueueBuilder.builder(client, consumer, serializer, "/zk_queue_test").buildQueue();

        try {
            //启动所有队列实例，让它们开始工作，注意所有指定的动作只有在调用了queue1.start()方法之后才会被执行，比如queue.put()等。
            //Curator提供了queue.put()方法来往队列里添加数据，但它同时也会处理，但我们不想这样，所以添加的过程我们通过其它的方式来实现。
            queue1.start();
            queue2.start();
            System.out.println("Queues started!");
        } catch (Exception e) {

        }
    }
}
</code></pre>

<h3>2.2、数据系列化处理工具类：QueueSerializer.java</h3>

<pre><code>package cn.bg.zk.queues;

public class QueueItemSerializer implements QueueSerializer&lt;String&gt;
{
    @Override
    public byte[] serialize(String item)
    {
        return item.getBytes();
    }

    @Override
    public String deserialize(byte[] bytes)
    {
        return new String(new String(bytes));
    }
}
</code></pre>

<p>上面的是消息队列处理的部分，下面开始消息添加，也就是生产者部分：</p>

<h3>2.3、生成者控制器类：MainController.java</h3>

<p>生产者是一个Controller，也就是通过用户提交数据来做为生产者</p>

<pre><code>package cn.bg.controller;

@Controller
public class MainController {

    private final CuratorFramework zkClient;
    //通过Spring注入CuratorFramework实例
    public MainController(final CuratorFramework zkClient) {
        Assert.notNull(zkClient, "zkClient cannot be null");
        this.zkClient = zkClient;
    }

    //简单的使用传递值来做数据处理的实体
    @RequestMapping("/put/{val}")
    @ResponseBody
    public String put(@PathVariable String val) throws Exception {
        //需要使用特定的格式来添加数据到队列，使用ItemSerializer来做格式化生成byte。
        byte[] bytes = ItemSerializer.serialize(val, new QueueItemSerializer());
        String path = "" ;    

        //创建znode并添加数据
        path = zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/zk_queue_test/queue-");
        zkClient.setData().forPath(path, bytes);
        return path;
    }

}
</code></pre>

<h3>2.4、格式化数据类：ItemSerializer.java</h3>

<p>这个类是格式化数据，也就是设置一些znode的属性，并生成byte</p>

<p>此类来自Curator源码的简化版，主要目的是分离Curator Queue来添加队列数据用到。</p>

<pre><code>package cn.bg.zk.queues;

public class ItemSerializer {
    private static final int VERSION = 0x00010001;

    private static final byte ITEM_OPCODE = 0x01;
    private static final byte EOF_OPCODE = 0x02;

    private static final int INITIAL_BUFFER_SIZE = 0x1000;

    public static &lt;T&gt; byte[] serialize(T item, QueueSerializer&lt;T&gt; serializer) throws Exception {
        ByteArrayOutputStream bytes = new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);
        DataOutputStream out = new DataOutputStream(bytes);
        out.writeInt(VERSION);

        byte[] itemBytes = serializer.serialize(item);
        out.writeByte(ITEM_OPCODE);
        out.writeInt(itemBytes.length);
        if (itemBytes.length &gt; 0) {
            out.write(itemBytes);
        }

        out.writeByte(EOF_OPCODE);
        out.close();

        return bytes.toByteArray();
    }
}
</code></pre>

<h2>三、运行</h2>

<p>启动应用后所有队列都已处理待命状态，理论上只要在ZK目录 /zk_queue_test/ 添加数据就会被处理掉，只是它有固定的添加格式。</p>

<p>通过访问 /put/{?} 等这样路径数据 {?} 就会被添加到队列并处理，所以可以刷多条数据到队列来观察队列的处理状态，基本的输出应该是这样的：</p>

<pre><code>17 consume: 111
18 consume: 222
17 consume: 111
18 consume: 222
17 consume: 111
17 consume: 111
</code></pre>

<p>整个过程基本完成，经测试运行状态良好，Curator自己维护与ZK集群的连接，本人通过JMX将应用与ZK的连接强制断开后Curator主动识别并重新连接，基本不用担心一些基础问题上处理，可以专心解决我们的业务需要。</p>

<p><strong>Zookeeper和Curator-Framework实践之：分布式消息队列：<a href="http://www.tuicool.com/articles/7bAjEr">http://www.tuicool.com/articles/7bAjEr</a></strong></p>

<br/>
<div style="margin-top:10px;margin-bottom:10px">
  
  <span class="next">
    上篇：
    <a href="/2014/11/02-Jenkins-Config.html">
      Jenkins配置
    </a>
  </span>
   
  
  <span class="prev">
    下篇：
    <a href="/2014/11/Distributed-Message-Passing-Config.html">
      Zookeeper和Curator-Framework实践系列之： 配置管理
    </a>
  </span>
  
</div>
<hr>
<!-- Blog Comments -->
<div class="media">
    <!-- UY BEGIN -->
  <div id="uyan_frame">
  </div>
  <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=1511840">
  </script>
  <!-- UY END --> 
</div>

        </article>
      </div>
    </div>
    <footer>
      <div class="owner">

      <p><a href="https://github.com/mwb1219" class="avatar"><img src="https://avatars1.githubusercontent.com/u/9292203?v=3&amp;s=60" width="48" height="48"></a>View <a href="https://github.com/mwb1219">mwb1219</a> on <a href="https://www.github.com">GitHub</a></p>

      </div>
      <div class="creThis page generated using <a href="http://pages.github.com/">GitHub Pages</a><br>theme by <a href="https://twitter.com/jonrohan/">Jon Rohan</a>i>

</ul></small>
      </div>
    </footer>
  </div>
  <div class="current-section">
    <a href="#top">Scroll to top</a>
    <a href="https://github.com/mwb1219/mwb1219.github.io/tarball/master" class="tar">tar</a><a href="https://github.com/mwb1219/mwb1219.github.io/zipball/master" class="zip">zip</a><a href="" class="code">source code</a>
    <p class="name"></p>
  </div>
  
</body>
</html>